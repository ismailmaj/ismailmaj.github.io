{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/destructing-trees-safely-and-cheaply","result":{"data":{"post":{"slug":"/destructing-trees-safely-and-cheaply","title":"Destructing trees safely and cheaply","date":"05.11.2022","tags":[{"name":"Rust, Performance","slug":"rust-performance"}],"description":"Destructing trees safely and cheaply","canonicalUrl":null,"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Destructing trees safely and cheaply\",\n  \"date\": \"2022-11-05T00:00:00.000Z\",\n  \"description\": \"Destructing trees safely and cheaply\",\n  \"tags\": [\"Rust, Performance\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null), mdx(\"p\", null, \"Trees in the wild can be arbitrarily deep, while this is a non-problem in garbage collected languages such as Java and Go, not every application can afford GC pauses.\"), mdx(\"p\", null, \"Garbage collection is known to increase long tail latencies, which in turn can deteriorate user experience.  \"), mdx(\"p\", null, \"This leads us to manually managed memory languages such as C++ and Rust.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"Rust's memory management strategy based on ownership is better suited to express this problem so we'll use it for the remainder of this article.  \"), mdx(\"p\", null, \"Let's start with a degenerate version of binary trees: linked lists!\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"They can be seen as a binary tree with only left (or only right) nodes.  \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"pub struct LinkedList<T> {\\n    // `Box` is Rust's type to represent heap allocated objects\\n    root: Option<Box<ListNode<T>>>,\\n}\\n\\nstruct ListNode<T> {\\n    datum: T,\\n    next: Option<Box<ListNode<T>>>,\\n}\\n\\nimpl<T> LinkedList<T> {\\n    pub fn push_front(&mut self, datum: T) {\\n        self.root = Some(Box::new(ListNode {\\n            datum,\\n            next: self.root.take(),\\n        }));\\n    }\\n}\\n\\nfn main() {\\n    let length = std::env::args()\\n        .skip(1)\\n        .next()\\n        .expect(\\\"linked list length missing\\\")\\n        .parse()\\n        .expect(\\\"invalid unsigned integer\\\");\\n\\n    println!(\\\"creating a linked list of length {}\\\", length);\\n    let mut linked_list = LinkedList { root: None }; \\n    for i in 0..length {\\n        linked_list.push_front(i);\\n    }\\n    println!(\\\"linked list created\\\");\\n}\\n\")), mdx(\"p\", null, \"The main function is pretty simple, it reads the first argument and creates a linked list of that length.  \"), mdx(\"p\", null, \"Let's try it out with a parameter of one million.  \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \">> cargo run --release 1000000\\ncreating a linked list of length 1000000\\nlinked list created\\n\\nthread 'main' has overflowed its stack\\nfatal runtime error: stack overflow\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Uh oh.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"What happened?  \")), mdx(\"p\", null, \"To ensure that the linked list's memory is reclaimed, a destructor is run once the struct goes out of scope, all of its fields are dropped \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"recursively\"), \" (same behavior as C++ smart pointers).\"), mdx(\"p\", null, \"The root destructor calls the next node destructor ..., the call stack keeps growing, in fact as much as the linked list length, but the main thread stack size is fixed. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"stack overflow\"), \" \\uD83D\\uDCA5  \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"    LinkedList {                        // vvv n-2 drop call, ^^^ dropped third\\n        datum: 2,\\n        next: Some(LinkedList {     // vvv n-1 drop call, ^^^ dropped second\\n            datum: 1,\\n            next: Some(LinkedList { // vvv nth drop call, ^^^ dropped first\\n                datum: 0,\\n                next: None,\\n            }),\\n        }),\\n    };\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Is there a way to fix this?  \")), mdx(\"p\", null, \"Yes! by using tail recursion.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"A function calling itself recursively as its \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"last\"), \" action can have its stack frame safely removed and replaced.  \"), mdx(\"p\", null, \"Let's write a custom destructor to see if it works!  \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"impl<T> Drop for ListNode<T> {\\n    fn drop(&mut self) {\\n        if let Some(node) = self.next.take() {\\n            let owned_node = *node;\\n            drop(owned_node); // for good measure\\n        }\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \">> cargo run --release 1000000\\ncreating a linked list of length 1000000\\nlinked list created\\n\\nthread 'main' has overflowed its stack\\nfatal runtime error: stack overflow\\n\")), mdx(\"p\", null, \"Uhh, this is awkward.\"), mdx(\"p\", null, \"Tail recursion isn't \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/59257543/when-is-tail-recursion-guaranteed-in-rust\"\n  }, \"guaranteed\"), \" in Rust, however, it's possible to emulate using a well crafted constant memory loop.  \"), mdx(\"p\", null, \"It is in fact what the standard library does for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::collections::LinkedList\"), \".  \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"while let Some(node) = self.pop_front_node() {\\n    // ... stuff to handle panics\\n    drop(node);\\n}\\n\")), mdx(\"p\", null, \"Cool.  \"), mdx(\"p\", null, \"Now, let's get back to binary trees, it looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"type TreeNodeRef<T> = Option<Box<TreeNode<T>>>;\\n\\npub struct Tree<T> {\\n    root: TreeNodeRef<T>,\\n}\\n\\nstruct TreeNode<T> {\\n    datum: T,\\n    left: TreeNodeRef<T>,\\n    right: TreeNodeRef<T>,\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Is there a way to prevent stack overflow during the destruction of a deep binary tree?  \")), mdx(\"p\", null, \"Since every node can have two childrens there isn't an obvious way to apply our previous trick...\"), mdx(\"p\", null, \"Not only this is possible but it can be done in constant memory!\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"impl<T> Drop for Tree<T> {\\n    fn drop(&mut self) {\\n        let Some(mut node) = self.root.take() else { return; };\\n        loop {\\n            let TreeNode { left, right, .. } = *node;\\n\\n            match (left, right) {\\n                (Some(mut left), Some(right)) => {\\n                    let mut predecessor = &mut left;\\n                    while predecessor.right.is_some() {\\n                        predecessor = predecessor.right.as_mut().unwrap();\\n                    }\\n                    predecessor.right = Some(right);\\n                    node = left;\\n                }\\n                (Some(next), None) | (None, Some(next)) => {\\n                    node = next;\\n                }\\n                _ => break,\\n            }\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"The idea is to restructure the binary tree into a linked list!  \"), mdx(\"p\", null, \"Whenever a node have two childrens, we transfer the ownership of the right child to the inorder predecessor present in the left child. This is free in term of memory as the inorder predecessor 's right child is necessarily \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"None\"), \" (proof by contradiction) and takes as much space as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Box<_>\"), \".  \"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Very cool, but what is the runtime cost of this?  \")), mdx(\"p\", null, \"Every edge (indirection) is visited at most two times, once to attain a node and a second time to search for the predecessor of another node. A binary tree of n nodes has n-1 edges so the runtime cost is at most 2n.   \"), mdx(\"p\", null, \"This algorithm can be seen as a faster, destructive variant of the preorder Morris traversal.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"It is also generalizable to n-ary trees.  \"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Trees in the wild can be arbitrarily deep, while this is a non-problem in garbage collected languages such as Java and Go, not everyâ€¦","timeToRead":2,"banner":null}},"pageContext":{"slug":"/destructing-trees-safely-and-cheaply","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["2744905544","3090400250","318001574"]}